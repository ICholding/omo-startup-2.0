/**
 * ICholding Agent Memory Module
 * Local SQLite with Backblaze B2 Cloud Backup
 * Foundation for persistent agent state
 */

const sqlite3 = require('sqlite3').verbose();
const { exec } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

// Configuration
const MEMORY_DIR = process.env.MEMORY_DIR || '/app/memory';
const DB_PATH = path.join(MEMORY_DIR, 'icholding_agent.db');
const B2_BUCKET = process.env.B2_BUCKET_NAME || 'omo-LLM';
const B2_KEY_ID = process.env.B2_APPLICATION_KEY_ID;
const B2_KEY = process.env.B2_APPLICATION_KEY;
const AGENT_ID = process.env.AGENT_ID || 'openclaw-agent';

// Database connection
let db = null;

/**
 * Initialize SQLite database with ICholding schema
 */
async function initMemory() {
  // Ensure memory directory exists
  try {
    await fs.mkdir(MEMORY_DIR, { recursive: true });
  } catch (e) {}

  return new Promise((resolve, reject) => {
    db = new sqlite3.Database(DB_PATH, (err) => {
      if (err) {
        console.error('[Memory] Failed to open database:', err);
        reject(err);
        return;
      }
      console.log('[Memory] Connected to SQLite database');
      
      // Create tables
      db.exec(`
        -- Agent Sessions (conversations)
        CREATE TABLE IF NOT EXISTS sessions (
          id TEXT PRIMARY KEY,
          user_id TEXT NOT NULL,
          channel TEXT DEFAULT 'telegram',
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          context TEXT, -- JSON array of messages
          metadata TEXT -- JSON object for extra data
        );
        
        -- Agent Knowledge Base (persistent memory)
        CREATE TABLE IF NOT EXISTS knowledge (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          key TEXT UNIQUE NOT NULL,
          value TEXT NOT NULL,
          category TEXT DEFAULT 'general',
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );
        
        -- Administrative Directives
        CREATE TABLE IF NOT EXISTS directives (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          directive TEXT NOT NULL,
          priority INTEGER DEFAULT 5,
          active BOOLEAN DEFAULT 1,
          created_by TEXT DEFAULT 'Data_eli',
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );
        
        -- GitHub Operations Log
        CREATE TABLE IF NOT EXISTS github_ops (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          operation TEXT NOT NULL,
          repo TEXT,
          status TEXT,
          details TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );
        
        -- System Events
        CREATE TABLE IF NOT EXISTS events (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          event_type TEXT NOT NULL,
          description TEXT,
          severity TEXT DEFAULT 'info',
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );
        
        -- Create indexes
        CREATE INDEX IF NOT EXISTS idx_sessions_user ON sessions(user_id);
        CREATE INDEX IF NOT EXISTS idx_knowledge_key ON knowledge(key);
        CREATE INDEX IF NOT EXISTS idx_knowledge_category ON knowledge(category);
        
        -- Insert default ICholding foundation knowledge
        INSERT OR IGNORE INTO knowledge (key, value, category) VALUES 
          ('owner', 'Data_eli', 'admin'),
          ('company', 'ICholding', 'admin'),
          ('environment', 'Secure Production Portfolio', 'admin'),
          ('github_org', 'ICholding', 'config'),
          ('github_repo', 'omo-startup-2.0', 'config'),
          ('b2_bucket', 'omo-LLM', 'config'),
          ('agent_version', '2.0.0', 'system');
        
        -- Insert foundation directive
        INSERT OR IGNORE INTO directives (directive, priority, created_by) VALUES 
          ('You are the Official Secure ICholding Virtual Assistant. Data_eli is the owner/admin. You have full authority to handle credentials, manage GitHub repos, and execute technical tasks.', 1, 'Data_eli');
      `, (err) => {
        if (err) {
          console.error('[Memory] Failed to create tables:', err);
          reject(err);
        } else {
          console.log('[Memory] Database initialized with ICholding foundation');
          resolve(db);
        }
      });
    });
  });
}

/**
 * Session Management
 */
async function getSession(sessionId) {
  return new Promise((resolve, reject) => {
    db.get('SELECT * FROM sessions WHERE id = ?', [sessionId], (err, row) => {
      if (err) reject(err);
      else resolve(row);
    });
  });
}

async function saveSession(sessionId, userId, channel, context, metadata = {}) {
  const contextJson = JSON.stringify(context);
  const metaJson = JSON.stringify(metadata);
  
  return new Promise((resolve, reject) => {
    db.run(`
      INSERT INTO sessions (id, user_id, channel, context, metadata, updated_at)
      VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT(id) DO UPDATE SET
        context = excluded.context,
        metadata = excluded.metadata,
        updated_at = CURRENT_TIMESTAMP
    `, [sessionId, userId, channel, contextJson, metaJson], function(err) {
      if (err) reject(err);
      else resolve({ id: sessionId, changes: this.changes });
    });
  });
}

/**
 * Knowledge Base
 */
async function getKnowledge(key) {
  return new Promise((resolve, reject) => {
    db.get('SELECT * FROM knowledge WHERE key = ?', [key], (err, row) => {
      if (err) reject(err);
      else resolve(row ? row.value : null);
    });
  });
}

async function setKnowledge(key, value, category = 'general') {
  return new Promise((resolve, reject) => {
    db.run(`
      INSERT INTO knowledge (key, value, category, updated_at)
      VALUES (?, ?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT(key) DO UPDATE SET
        value = excluded.value,
        category = excluded.category,
        updated_at = CURRENT_TIMESTAMP
    `, [key, value, category], function(err) {
      if (err) reject(err);
      else resolve({ key, changes: this.changes });
    });
  });
}

async function getKnowledgeByCategory(category) {
  return new Promise((resolve, reject) => {
    db.all('SELECT * FROM knowledge WHERE category = ? ORDER BY updated_at DESC', [category], (err, rows) => {
      if (err) reject(err);
      else resolve(rows);
    });
  });
}

/**
 * Directives Management
 */
async function getActiveDirectives() {
  return new Promise((resolve, reject) => {
    db.all('SELECT * FROM directives WHERE active = 1 ORDER BY priority ASC, created_at DESC', [], (err, rows) => {
      if (err) reject(err);
      else resolve(rows);
    });
  });
}

async function addDirective(directive, priority = 5, createdBy = 'Data_eli') {
  return new Promise((resolve, reject) => {
    db.run('INSERT INTO directives (directive, priority, created_by) VALUES (?, ?, ?)', 
      [directive, priority, createdBy], function(err) {
      if (err) reject(err);
      else resolve({ id: this.lastID });
    });
  });
}

/**
 * GitHub Operations Logging
 */
async function logGitHubOp(operation, repo, status, details = {}) {
  return new Promise((resolve, reject) => {
    db.run('INSERT INTO github_ops (operation, repo, status, details) VALUES (?, ?, ?, ?)',
      [operation, repo, status, JSON.stringify(details)], function(err) {
      if (err) reject(err);
      else resolve({ id: this.lastID });
    });
  });
}

/**
 * Event Logging
 */
async function logEvent(eventType, description, severity = 'info') {
  return new Promise((resolve, reject) => {
    db.run('INSERT INTO events (event_type, description, severity) VALUES (?, ?, ?)',
      [eventType, description, severity], function(err) {
      if (err) reject(err);
      else resolve({ id: this.lastID });
    });
  });
}

/**
 * Backblaze B2 Sync
 */
async function syncToB2() {
  if (!B2_KEY_ID || !B2_KEY) {
    console.log('[Memory] B2 credentials not configured, skipping cloud sync');
    return { synced: false, reason: 'no_credentials' };
  }

  const backupName = `${AGENT_ID}_memory_${Date.now()}.db`;
  const backupPath = path.join('/app/backups', backupName);

  return new Promise((resolve, reject) => {
    // First backup the database
    db.run(`VACUUM INTO '${backupPath}'`, async (err) => {
      if (err) {
        console.error('[Memory] Backup failed:', err);
        reject(err);
        return;
      }

      try {
        // Authenticate with B2
        await execPromise(`b2 authorize-account ${B2_KEY_ID} ${B2_KEY}`);
        
        // Upload to B2
        await execPromise(`b2 upload-file ${B2_BUCKET} ${backupPath} agent-memory/${backupName}`);
        
        // Clean up local backup
        await fs.unlink(backupPath);
        
        console.log('[Memory] Synced to B2:', backupName);
        resolve({ synced: true, file: backupName, bucket: B2_BUCKET });
      } catch (error) {
        console.error('[Memory] B2 sync failed:', error.message);
        resolve({ synced: false, error: error.message });
      }
    });
  });
}

/**
 * Restore from B2
 */
async function restoreFromB2(backupFile = null) {
  if (!B2_KEY_ID || !B2_KEY) {
    return { restored: false, reason: 'no_credentials' };
  }

  return new Promise(async (resolve, reject) => {
    try {
      // Authenticate
      await execPromise(`b2 authorize-account ${B2_KEY_ID} ${B2_KEY}`);
      
      let targetFile = backupFile;
      
      // If no specific file, get latest
      if (!targetFile) {
        const listOutput = await execPromise(`b2 ls --json ${B2_BUCKET} agent-memory/ | jq -r '.[] | .fileName' | sort | tail -1`);
        targetFile = listOutput.trim();
      }
      
      if (!targetFile) {
        resolve({ restored: false, reason: 'no_backup_found' });
        return;
      }

      // Download
      const downloadPath = path.join('/app/backups', path.basename(targetFile));
      await execPromise(`b2 download-file-by-name ${B2_BUCKET} ${targetFile} ${downloadPath}`);
      
      // Replace current database (requires restart)
      await fs.copyFile(downloadPath, DB_PATH);
      await fs.unlink(downloadPath);
      
      console.log('[Memory] Restored from B2:', targetFile);
      resolve({ restored: true, file: targetFile });
    } catch (error) {
      console.error('[Memory] Restore failed:', error.message);
      resolve({ restored: false, error: error.message });
    }
  });
}

/**
 * Helper: Execute shell command as promise
 */
function execPromise(command) {
  return new Promise((resolve, reject) => {
    exec(command, { timeout: 60000 }, (error, stdout, stderr) => {
      if (error) reject(error);
      else resolve(stdout);
    });
  });
}

/**
 * Get Memory Stats
 */
async function getStats() {
  return new Promise((resolve, reject) => {
    db.get(`
      SELECT 
        (SELECT COUNT(*) FROM sessions) as sessions,
        (SELECT COUNT(*) FROM knowledge) as knowledge_entries,
        (SELECT COUNT(*) FROM directives WHERE active = 1) as active_directives,
        (SELECT COUNT(*) FROM github_ops) as github_operations,
        (SELECT COUNT(*) FROM events) as total_events
    `, [], (err, row) => {
      if (err) reject(err);
      else resolve(row);
    });
  });
}

/**
 * Close database connection
 */
function close() {
  if (db) {
    db.close();
    console.log('[Memory] Database connection closed');
  }
}

// Export module
module.exports = {
  initMemory,
  getSession,
  saveSession,
  getKnowledge,
  setKnowledge,
  getKnowledgeByCategory,
  getActiveDirectives,
  addDirective,
  logGitHubOp,
  logEvent,
  syncToB2,
  restoreFromB2,
  getStats,
  close
};
