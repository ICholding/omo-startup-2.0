/**
 * ICholding GitHub Integration Module
 * Full GitHub API access via Octokit
 * Phase 1: GitHub Power-Up
 */

const { Octokit } = require('octokit');
const { graphql } = require('@octokit/graphql');

// Configuration
const GITHUB_TOKEN = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
const DEFAULT_OWNER = process.env.GITHUB_OWNER || 'ICholding';
const DEFAULT_REPO = process.env.GITHUB_REPO || 'omo-startup-2.0';

// Initialize Octokit
let octokit = null;
let graphqlWithAuth = null;

function initGitHub() {
  if (!GITHUB_TOKEN) {
    console.log('[GitHub] No token configured, GitHub features disabled');
    return false;
  }

  try {
    octokit = new Octokit({
      auth: GITHUB_TOKEN,
      userAgent: 'ICholding-Agent/2.0'
    });

    graphqlWithAuth = graphql.defaults({
      headers: {
        authorization: `token ${GITHUB_TOKEN}`,
      },
    });

    console.log('[GitHub] Octokit initialized successfully');
    return true;
  } catch (error) {
    console.error('[GitHub] Initialization failed:', error.message);
    return false;
  }
}

/**
 * Repository Operations
 */
async function listRepositories(owner = DEFAULT_OWNER) {
  try {
    const { data } = await octokit.rest.repos.listForOrg({
      org: owner,
      sort: 'updated',
      per_page: 100
    });
    return { success: true, repos: data };
  } catch (error) {
    // Try user repos if org fails
    try {
      const { data } = await octokit.rest.repos.listForUser({
        username: owner,
        sort: 'updated',
        per_page: 100
      });
      return { success: true, repos: data };
    } catch (e) {
      return { success: false, error: error.message };
    }
  }
}

async function getRepository(owner = DEFAULT_OWNER, repo = DEFAULT_REPO) {
  try {
    const { data } = await octokit.rest.repos.get({
      owner,
      repo
    });
    return { success: true, repo: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function createRepository(name, description = '', isPrivate = true, org = DEFAULT_OWNER) {
  try {
    const { data } = await octokit.rest.repos.createInOrg({
      org,
      name,
      description,
      private: isPrivate,
      auto_init: true
    });
    return { success: true, repo: data };
  } catch (error) {
    // Try creating for user if org fails
    try {
      const { data } = await octokit.rest.repos.createForAuthenticatedUser({
        name,
        description,
        private: isPrivate,
        auto_init: true
      });
      return { success: true, repo: data };
    } catch (e) {
      return { success: false, error: error.message };
    }
  }
}

/**
 * File Operations
 */
async function getFileContents(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, path, ref = 'main') {
  try {
    const { data } = await octokit.rest.repos.getContent({
      owner,
      repo,
      path,
      ref
    });
    
    // Decode content if it's a file
    if (data.content && data.encoding === 'base64') {
      data.decodedContent = Buffer.from(data.content, 'base64').toString('utf8');
    }
    
    return { success: true, content: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function createOrUpdateFile(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, path, content, message, branch = 'main') {
  try {
    // Try to get existing file to get SHA
    let sha = null;
    try {
      const { data } = await octokit.rest.repos.getContent({
        owner,
        repo,
        path,
        ref: branch
      });
      sha = data.sha;
    } catch (e) {
      // File doesn't exist, will create new
    }

    const params = {
      owner,
      repo,
      path,
      message,
      content: Buffer.from(content).toString('base64'),
      branch
    };

    if (sha) {
      params.sha = sha;
    }

    const { data } = await octokit.rest.repos.createOrUpdateFileContents(params);
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function deleteFile(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, path, message, sha, branch = 'main') {
  try {
    const { data } = await octokit.rest.repos.deleteFile({
      owner,
      repo,
      path,
      message,
      sha,
      branch
    });
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Issue Operations
 */
async function listIssues(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, state = 'open') {
  try {
    const { data } = await octokit.rest.issues.listForRepo({
      owner,
      repo,
      state,
      per_page: 100
    });
    return { success: true, issues: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function createIssue(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, title, body, labels = []) {
  try {
    const { data } = await octokit.rest.issues.create({
      owner,
      repo,
      title,
      body,
      labels
    });
    return { success: true, issue: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function updateIssue(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, issueNumber, title, body, state, labels) {
  try {
    const params = { owner, repo, issue_number: issueNumber };
    if (title) params.title = title;
    if (body) params.body = body;
    if (state) params.state = state;
    if (labels) params.labels = labels;

    const { data } = await octokit.rest.issues.update(params);
    return { success: true, issue: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Pull Request Operations
 */
async function listPullRequests(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, state = 'open') {
  try {
    const { data } = await octokit.rest.pulls.list({
      owner,
      repo,
      state,
      per_page: 100
    });
    return { success: true, pulls: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function createPullRequest(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, title, head, base, body) {
  try {
    const { data } = await octokit.rest.pulls.create({
      owner,
      repo,
      title,
      head,
      base,
      body
    });
    return { success: true, pull: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function mergePullRequest(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, pullNumber, commitTitle, commitMessage) {
  try {
    const { data } = await octokit.rest.pulls.merge({
      owner,
      repo,
      pull_number: pullNumber,
      commit_title: commitTitle,
      commit_message: commitMessage
    });
    return { success: true, merge: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Branch Operations
 */
async function listBranches(owner = DEFAULT_OWNER, repo = DEFAULT_REPO) {
  try {
    const { data } = await octokit.rest.repos.listBranches({
      owner,
      repo,
      per_page: 100
    });
    return { success: true, branches: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function createBranch(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, branch, fromBranch = 'main') {
  try {
    // Get SHA of source branch
    const { data: refData } = await octokit.rest.git.getRef({
      owner,
      repo,
      ref: `heads/${fromBranch}`
    });

    // Create new branch
    const { data } = await octokit.rest.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branch}`,
      sha: refData.object.sha
    });

    return { success: true, ref: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Commit Operations
 */
async function listCommits(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, branch = 'main') {
  try {
    const { data } = await octokit.rest.repos.listCommits({
      owner,
      repo,
      sha: branch,
      per_page: 100
    });
    return { success: true, commits: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * GraphQL Queries for Advanced Operations
 */
async function getRepositoryInfoGraphQL(owner = DEFAULT_OWNER, repo = DEFAULT_REPO) {
  try {
    const query = `
      query($owner: String!, $repo: String!) {
        repository(owner: $owner, name: $repo) {
          id
          name
          description
          url
          stargazerCount
          forkCount
          issues(states: OPEN) {
            totalCount
          }
          pullRequests(states: OPEN) {
            totalCount
          }
          defaultBranchRef {
            name
          }
        }
      }
    `;

    const result = await graphqlWithAuth(query, { owner, repo });
    return { success: true, repository: result.repository };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * User Operations
 */
async function getAuthenticatedUser() {
  try {
    const { data } = await octokit.rest.users.getAuthenticated();
    return { success: true, user: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function listUserRepos(username) {
  try {
    const { data } = await octokit.rest.repos.listForUser({
      username,
      sort: 'updated',
      per_page: 100
    });
    return { success: true, repos: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Webhook Operations
 */
async function listWebhooks(owner = DEFAULT_OWNER, repo = DEFAULT_REPO) {
  try {
    const { data } = await octokit.rest.repos.listWebhooks({
      owner,
      repo
    });
    return { success: true, hooks: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function createWebhook(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, config, events = ['push']) {
  try {
    const { data } = await octokit.rest.repos.createWebhook({
      owner,
      repo,
      config,
      events
    });
    return { success: true, hook: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Workflow Operations
 */
async function listWorkflows(owner = DEFAULT_OWNER, repo = DEFAULT_REPO) {
  try {
    const { data } = await octokit.rest.actions.listRepoWorkflows({
      owner,
      repo
    });
    return { success: true, workflows: data.workflows };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function triggerWorkflow(owner = DEFAULT_OWNER, repo = DEFAULT_REPO, workflowId, branch = 'main', inputs = {}) {
  try {
    await octokit.rest.actions.createWorkflowDispatch({
      owner,
      repo,
      workflow_id: workflowId,
      ref: branch,
      inputs
    });
    return { success: true, message: 'Workflow triggered' };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// Export all functions
module.exports = {
  initGitHub,
  // Repos
  listRepositories,
  getRepository,
  createRepository,
  // Files
  getFileContents,
  createOrUpdateFile,
  deleteFile,
  // Issues
  listIssues,
  createIssue,
  updateIssue,
  // Pull Requests
  listPullRequests,
  createPullRequest,
  mergePullRequest,
  // Branches
  listBranches,
  createBranch,
  // Commits
  listCommits,
  // GraphQL
  getRepositoryInfoGraphQL,
  // User
  getAuthenticatedUser,
  listUserRepos,
  // Webhooks
  listWebhooks,
  createWebhook,
  // Workflows
  listWorkflows,
  triggerWorkflow
};
