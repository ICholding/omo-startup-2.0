const express = require('express');
const { exec } = require('child_process');
const https = require('https');
const http = require('http');
const axios = require('axios'); // Will be installed

const app = express();
app.use(express.json({ limit: '10mb' }));

// Configuration
const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const OPENROUTER_API_URL = process.env.OPENROUTER_API_URL || 'https://openrouter.ai/api/v1';
const OPENROUTER_MODEL = process.env.OPENROUTER_MODEL || 'claude-3.5-sonnet';
const AGENT_ID = process.env.AGENT_ID || 'openclaw-agent';

// Agent state for polling
let agentState = {
  status: 'initializing',
  connected: false,
  lastPing: Date.now(),
  startTime: Date.now(),
  requestCount: 0,
  errorCount: 0,
  model: OPENROUTER_MODEL
};

// Logging middleware
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});

/**
 * Check OpenRouter connection
 */
async function checkOpenRouterConnection() {
  if (!OPENROUTER_API_KEY) {
    agentState.status = 'no_api_key';
    agentState.connected = false;
    return false;
  }

  try {
    const response = await axios.get(`${OPENROUTER_API_URL}/models`, {
      headers: {
        'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
        'HTTP-Referer': process.env.OMO_BACKEND_URL || 'https://omo-startup-backend.onrender.com',
        'X-Title': 'OMO OpenClaw Agent'
      },
      timeout: 10000
    });

    agentState.connected = true;
    agentState.status = 'online';
    agentState.lastPing = Date.now();
    return true;
  } catch (error) {
    agentState.connected = false;
    agentState.status = 'disconnected';
    agentState.errorCount++;
    console.error('[OpenClaw] OpenRouter connection failed:', error.message);
    return false;
  }
}

// Poll connection every 30 seconds
setInterval(checkOpenRouterConnection, 30000);
checkOpenRouterConnection();

/**
 * Execute network requests (HTTP/HTTPS)
 */
async function executeNetworkRequest(url, options = {}) {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https') ? https : http;
    const req = client.request(url, {
      method: options.method || 'GET',
      headers: options.headers || {}
    }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        resolve({
          statusCode: res.statusCode,
          headers: res.headers,
          body: data.substring(0, 10000)
        });
      });
    });

    req.on('error', (err) => reject({ error: err.message }));
    
    if (options.body) {
      req.write(JSON.stringify(options.body));
    }
    
    req.setTimeout(options.timeout || 30000, () => {
      req.destroy();
      reject({ error: 'Request timeout' });
    });
    
    req.end();
  });
}

/**
 * Execute system commands safely
 */
async function executeCommand(command, timeout = 30000) {
  return new Promise((resolve) => {
    const allowedCommands = ['curl', 'wget', 'node', 'python3', 'python', 'cat', 'echo', 'ls', 'grep', 'awk', 'sed', 'jq', 'git'];
    const cmdBase = command.split(' ')[0];
    
    if (!allowedCommands.includes(cmdBase)) {
      resolve({ 
        status: 'restricted', 
        message: `Command '${cmdBase}' not in allowed list. Available: ${allowedCommands.join(', ')}` 
      });
      return;
    }

    exec(command, { timeout, maxBuffer: 1024 * 1024 }, (error, stdout, stderr) => {
      if (error) {
        resolve({ 
          status: 'error', 
          error: error.message, 
          stderr: stderr?.substring(0, 5000) 
        });
      } else {
        resolve({ 
          status: 'success', 
          output: stdout?.substring(0, 10000),
          stderr: stderr?.substring(0, 5000) 
        });
      }
    });
  });
}

/**
 * Execute code (Node.js or Python)
 */
async function executeCode(code, language = 'javascript') {
  if (language === 'javascript' || language === 'node') {
    try {
      const vm = require('vm');
      const context = { console, require, exports, module, __dirname, __filename };
      vm.createContext(context);
      
      const result = vm.runInContext(code, context, { timeout: 10000 });
      return { status: 'success', result: String(result) };
    } catch (err) {
      return { status: 'error', error: err.message };
    }
  }
  
  if (language === 'python' || language === 'python3') {
    return executeCommand(`python3 -c "${code.replace(/"/g, '\\"')}"`);
  }
  
  return { status: 'error', error: `Unsupported language: ${language}` };
}

/**
 * Call OpenRouter for AI responses
 */
async function callOpenRouter(message, context = []) {
  if (!OPENROUTER_API_KEY) {
    return { status: 'error', error: 'OpenRouter API key not configured' };
  }

  try {
    const messages = [
      {
        role: 'system',
        content: `You are ${AGENT_ID}, an AI assistant with technical capabilities including network requests, code execution, and system commands. Be helpful, concise, and security-conscious.`
      },
      ...(context || []),
      { role: 'user', content: message }
    ];

    const response = await axios.post(
      `${OPENROUTER_API_URL}/chat/completions`,
      {
        model: OPENROUTER_MODEL,
        messages,
        temperature: 0.7,
        max_tokens: 2000
      },
      {
        headers: {
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': process.env.OMO_BACKEND_URL || 'https://omo-startup-backend.onrender.com',
          'X-Title': 'OMO OpenClaw Agent'
        },
        timeout: 120000
      }
    );

    agentState.requestCount++;

    return {
      status: 'success',
      message: response.data.choices?.[0]?.message?.content,
      model: OPENROUTER_MODEL,
      usage: response.data.usage
    };

  } catch (error) {
    agentState.errorCount++;
    return {
      status: 'error',
      error: error.message,
      details: error.response?.data
    };
  }
}

// Root route
app.get('/', (req, res) => {
  res.json({ 
    status: 'ok', 
    service: 'openclaw',
    version: '2.0.0',
    agent: {
      id: AGENT_ID,
      model: OPENROUTER_MODEL,
      connected: agentState.connected,
      status: agentState.status
    },
    capabilities: [
      'ai_chat',
      'network_requests', 
      'code_execution', 
      'system_commands', 
      'file_operations',
      'github_integration',
      'b2_storage'
    ],
    endpoints: {
      health: '/health',
      agentStatus: '/agent/status',
      agentPoll: '/agent/poll',
      chat: '/api/chat/message (POST)',
      execute: '/api/execute (POST)'
    }
  });
});

// Health check with agent status
app.get('/health', (req, res) => {
  const uptime = Date.now() - agentState.startTime;
  res.json({ 
    status: agentState.status,
    healthy: agentState.connected,
    uptime: Math.floor(uptime / 1000),
    service: 'openclaw',
    agent: {
      id: AGENT_ID,
      model: agentState.model,
      connected: agentState.connected
    },
    stats: {
      requests: agentState.requestCount,
      errors: agentState.errorCount
    },
    timestamp: new Date().toISOString()
  });
});

// Agent status endpoint (for polling)
app.get('/agent/status', (req, res) => {
  res.json({
    id: AGENT_ID,
    status: agentState.status,
    connected: agentState.connected,
    lastPing: agentState.lastPing,
    model: agentState.model,
    provider: 'openrouter',
    timestamp: new Date().toISOString()
  });
});

// Agent poll endpoint (POST for connection check)
app.post('/agent/poll', async (req, res) => {
  const isConnected = await checkOpenRouterConnection();
  res.json({
    connected: isConnected,
    status: agentState.status,
    model: agentState.model,
    timestamp: new Date().toISOString()
  });
});

// Main chat endpoint with AI
app.post('/api/chat/message', async (req, res) => {
  const { message, sessionId, context = [], from, username, channel } = req.body || {};
  
  if (!message) {
    return res.status(400).json({ error: 'message is required' });
  }

  console.log(`[OpenClaw] Chat request from ${username || 'unknown'}: ${message.substring(0, 50)}...`);

  // Call OpenRouter for AI response
  const aiResponse = await callOpenRouter(message, context);

  if (aiResponse.status === 'error') {
    return res.status(502).json({
      error: aiResponse.error,
      message: 'AI service unavailable'
    });
  }

  res.json({
    message: aiResponse.message,
    sessionId: sessionId || `session_${Date.now()}`,
    model: aiResponse.model,
    timestamp: new Date().toISOString()
  });
});

// Technical task execution endpoint
app.post('/api/execute', async (req, res) => {
  const { task_type, command, parameters = {}, reason } = req.body || {};
  
  console.log(`[OpenClaw] Execute: ${task_type}, Command: ${command?.substring(0, 100)}...`);
  
  if (!task_type || !command) {
    return res.status(400).json({ 
      status: 'error', 
      error: 'Missing task_type or command' 
    });
  }

  try {
    let result;
    
    switch (task_type) {
      case 'network_request':
        result = await executeNetworkRequest(command, parameters);
        break;
        
      case 'system_command':
        result = await executeCommand(command, parameters.timeout);
        break;
        
      case 'code_execution':
        result = await executeCode(command, parameters.language || 'javascript');
        break;
        
      case 'file_operation':
        const fs = require('fs').promises;
        const path = require('path');
        const workDir = '/tmp/openclaw-work';
        
        try {
          await fs.mkdir(workDir, { recursive: true });
        } catch {}
        
        if (parameters.operation === 'write') {
          const filePath = path.join(workDir, parameters.filename || 'output.txt');
          await fs.writeFile(filePath, command, 'utf8');
          result = { status: 'success', message: `File written to ${filePath}` };
        } else if (parameters.operation === 'read') {
          const filePath = path.join(workDir, command);
          const content = await fs.readFile(filePath, 'utf8');
          result = { status: 'success', content: content?.substring(0, 10000) };
        } else {
          result = { status: 'error', error: 'Unknown file operation' };
        }
        break;
        
      case 'ai_chat':
        const aiResult = await callOpenRouter(command, parameters.context);
        result = aiResult;
        break;
        
      default:
        result = { status: 'error', error: `Unknown task type: ${task_type}` };
    }
    
    res.json({
      status: 'completed',
      task_type,
      reason,
      result,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('[OpenClaw] Execute error:', error);
    res.status(500).json({
      status: 'error',
      error: error.message || 'Task execution failed',
      timestamp: new Date().toISOString()
    });
  }
});

// Streaming endpoint
app.get('/api/chat/stream', async (req, res) => {
  const { message = '', sessionId } = req.query || {};

  if (!sessionId) {
    return res.status(400).json({ error: 'sessionId is required' });
  }

  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  const writeEvent = (event, data) => {
    res.write(`event: ${event}\n`);
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  };

  writeEvent('execution-start', { state: 'thinking', message: 'Processing with OpenClaw...' });

  // Call OpenRouter
  const aiResponse = await callOpenRouter(message);

  setTimeout(() => {
    writeEvent('execution-complete', {
      status: 'completed',
      summary: aiResponse.message || 'Processing complete',
      model: OPENROUTER_MODEL
    });
    writeEvent('done', { ok: true });
    res.end();
  }, 100);
});

// 404 handler
app.use((req, res) => {
  console.log(`[404] Route not found: ${req.method} ${req.url}`);
  res.status(404).json({ error: 'Not Found', path: req.url, method: req.method });
});

const port = process.env.PORT || 8080;
app.listen(port, '0.0.0.0', () => {
  console.log(`OpenClaw Agent Service listening on ${port}`);
  console.log(`Agent: ${AGENT_ID}`);
  console.log(`Model: ${OPENROUTER_MODEL}`);
  console.log(`Capabilities: AI chat, network requests, code execution, system commands, file operations`);
});
