const express = require('express');
const { exec } = require('child_process');
const https = require('https');
const http = require('http');

const app = express();
app.use(express.json());

// Logging middleware
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});

/**
 * Execute network requests (HTTP/HTTPS)
 */
async function executeNetworkRequest(url, options = {}) {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https') ? https : http;
    const req = client.request(url, {
      method: options.method || 'GET',
      headers: options.headers || {}
    }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        resolve({
          statusCode: res.statusCode,
          headers: res.headers,
          body: data.substring(0, 10000) // Limit response size
        });
      });
    });

    req.on('error', (err) => reject({ error: err.message }));
    
    if (options.body) {
      req.write(JSON.stringify(options.body));
    }
    
    req.setTimeout(options.timeout || 30000, () => {
      req.destroy();
      reject({ error: 'Request timeout' });
    });
    
    req.end();
  });
}

/**
 * Execute system commands safely
 */
async function executeCommand(command, timeout = 30000) {
  return new Promise((resolve) => {
    const allowedCommands = ['curl', 'wget', 'node', 'python3', 'python', 'cat', 'echo', 'ls', 'grep', 'awk', 'sed', 'jq'];
    const cmdBase = command.split(' ')[0];
    
    if (!allowedCommands.includes(cmdBase)) {
      resolve({ 
        status: 'restricted', 
        message: `Command '${cmdBase}' not in allowed list. Available: ${allowedCommands.join(', ')}` 
      });
      return;
    }

    exec(command, { timeout, maxBuffer: 1024 * 1024 }, (error, stdout, stderr) => {
      if (error) {
        resolve({ 
          status: 'error', 
          error: error.message, 
          stderr: stderr?.substring(0, 5000) 
        });
      } else {
        resolve({ 
          status: 'success', 
          output: stdout?.substring(0, 10000),
          stderr: stderr?.substring(0, 5000) 
        });
      }
    });
  });
}

/**
 * Execute code (Node.js or Python)
 */
async function executeCode(code, language = 'javascript') {
  if (language === 'javascript' || language === 'node') {
    try {
      // Create a sandboxed context
      const vm = require('vm');
      const context = { console, require, exports, module, __dirname, __filename };
      vm.createContext(context);
      
      const result = vm.runInContext(code, context, { timeout: 10000 });
      return { status: 'success', result: String(result) };
    } catch (err) {
      return { status: 'error', error: err.message };
    }
  }
  
  if (language === 'python' || language === 'python3') {
    return executeCommand(`python3 -c "${code.replace(/"/g, '\\"')}"`);
  }
  
  return { status: 'error', error: `Unsupported language: ${language}` };
}

// Root route
app.get('/', (req, res) => {
  res.json({ 
    status: 'ok', 
    service: 'moltbot-pentest',
    version: '2.0.0',
    capabilities: ['network_requests', 'code_execution', 'system_commands', 'data_processing']
  });
});

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', service: 'moltbot-pentest' });
});

// Legacy chat endpoint (fallback)
app.post('/api/chat/message', (req, res) => {
  const { message } = req.body || {};
  res.json({
    status: 'completed',
    summary: `Moltbot sandbox received: ${message}`,
    sections: { Runtime: 'Technical execution mode available' },
    nextActions: ['Use /api/execute for technical tasks']
  });
});

// NEW: Technical task execution endpoint
app.post('/api/execute', async (req, res) => {
  const { task_type, command, parameters = {}, reason } = req.body || {};
  
  console.log(`[Execute] Task: ${task_type}, Command: ${command?.substring(0, 100)}...`);
  
  if (!task_type || !command) {
    return res.status(400).json({ 
      status: 'error', 
      error: 'Missing task_type or command' 
    });
  }

  try {
    let result;
    
    switch (task_type) {
      case 'network_request':
        result = await executeNetworkRequest(command, parameters);
        break;
        
      case 'system_command':
        result = await executeCommand(command, parameters.timeout);
        break;
        
      case 'code_execution':
        result = await executeCode(command, parameters.language || 'javascript');
        break;
        
      case 'file_operation':
        // Basic file operations
        const fs = require('fs').promises;
        const path = require('path');
        const workDir = '/tmp/moltbot-work';
        
        try {
          await fs.mkdir(workDir, { recursive: true });
        } catch {}
        
        if (parameters.operation === 'write') {
          const filePath = path.join(workDir, parameters.filename || 'output.txt');
          await fs.writeFile(filePath, command, 'utf8');
          result = { status: 'success', message: `File written to ${filePath}` };
        } else if (parameters.operation === 'read') {
          const filePath = path.join(workDir, command);
          const content = await fs.readFile(filePath, 'utf8');
          result = { status: 'success', content: content?.substring(0, 10000) };
        } else {
          result = { status: 'error', error: 'Unknown file operation' };
        }
        break;
        
      case 'data_processing':
        // Simple data transformation
        try {
          let data = command;
          if (typeof data === 'string') {
            data = JSON.parse(data);
          }
          // Process based on parameters
          if (parameters.transform === 'json_to_csv') {
            // Simple JSON to CSV conversion
            result = { status: 'success', data: 'CSV conversion placeholder' };
          } else {
            result = { status: 'success', data };
          }
        } catch (err) {
          result = { status: 'error', error: err.message };
        }
        break;
        
      default:
        result = { status: 'error', error: `Unknown task type: ${task_type}` };
    }
    
    res.json({
      status: 'completed',
      task_type,
      reason,
      result,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('[Execute] Error:', error);
    res.status(500).json({
      status: 'error',
      error: error.message || 'Task execution failed',
      timestamp: new Date().toISOString()
    });
  }
});

// Streaming endpoint (for backward compatibility)
app.get('/api/chat/stream', (req, res) => {
  const { message = '', sessionId } = req.query || {};

  if (!sessionId) {
    return res.status(400).json({ error: 'sessionId is required' });
  }

  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  const writeEvent = (event, data) => {
    res.write(`event: ${event}\n`);
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  };

  writeEvent('execution-start', { state: 'thinking', message: 'Processing...' });

  setTimeout(() => {
    writeEvent('execution-complete', {
      status: 'completed',
      summary: `Moltbot received: ${message}`,
      sections: { Info: 'Use /api/execute for technical tasks' },
      nextActions: ['Use technical execution endpoint']
    });
    writeEvent('done', { ok: true });
    res.end();
  }, 50);
});

// 404 handler
app.use((req, res) => {
  console.log(`[404] Route not found: ${req.method} ${req.url}`);
  res.status(404).json({ error: 'Not Found', path: req.url, method: req.method });
});

const port = process.env.PORT || 8080;
app.listen(port, '0.0.0.0', () => {
  console.log(`Moltbot Technical Execution Service listening on ${port}`);
  console.log('Capabilities: network requests, code execution, system commands, file operations');
});
