/**
 * ICholding Secure Execution Module
 * Phase 3: Secure Execution with isolated-vm and Docker
 */

const ivm = require('isolated-vm');
const Docker = require('dockerode');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

// Configuration
const DOCKER_SOCKET = process.env.DOCKER_SOCKET || '/var/run/docker.sock';
const EXECUTION_TIMEOUT = parseInt(process.env.EXECUTION_TIMEOUT) || 30000;
const MEMORY_LIMIT = process.env.EXECUTION_MEMORY_LIMIT || '128m';

// Initialize Docker client
let docker = null;
try {
  docker = new Docker({ socketPath: DOCKER_SOCKET });
  console.log('[Executor] Docker client initialized');
} catch (error) {
  console.log('[Executor] Docker not available:', error.message);
}

/**
 * Execute JavaScript in isolated VM (Phase 3)
 */
async function executeIsolatedJS(code, timeout = EXECUTION_TIMEOUT) {
  const isolate = new ivm.Isolate({ memoryLimit: 128 }); // 128MB memory limit
  const context = await isolate.createContext();
  const jail = context.global;

  try {
    // Set up console in isolated context
    const logs = [];
    await jail.set('__log', new ivm.Reference((msg) => {
      logs.push(msg);
    }));

    await jail.set('console', {
      log: new ivm.Reference((...args) => {
        logs.push(args.map(a => String(a)).join(' '));
      }),
      error: new ivm.Reference((...args) => {
        logs.push('[ERROR] ' + args.map(a => String(a)).join(' '));
      })
    }, { copy: true });

    // Compile and run script
    const script = await isolate.compileScript(code);
    const result = await script.run(context, { timeout });

    // Dispose isolate
    isolate.dispose();

    return {
      success: true,
      result: typeof result === 'object' ? JSON.stringify(result) : String(result),
      logs: logs.slice(0, 100), // Limit logs
      type: typeof result
    };
  } catch (error) {
    isolate.dispose();
    return {
      success: false,
      error: error.message,
      logs: []
    };
  }
}

/**
 * Execute code in Docker container (Phase 3)
 */
async function executeInDocker(code, language = 'javascript', timeout = EXECUTION_TIMEOUT) {
  if (!docker) {
    return { success: false, error: 'Docker not available' };
  }

  // Map languages to Docker images
  const images = {
    javascript: 'node:20-alpine',
    python: 'python:3.11-alpine',
    bash: 'alpine:latest',
    go: 'golang:1.21-alpine',
    rust: 'rust:1.75-alpine',
    ruby: 'ruby:3.2-alpine'
  };

  const image = images[language];
  if (!image) {
    return { success: false, error: `Unsupported language: ${language}` };
  }

  // Prepare command based on language
  const commands = {
    javascript: ['node', '-e', code],
    python: ['python', '-c', code],
    bash: ['sh', '-c', code],
    go: ['sh', '-c', `echo '${code}' > /tmp/main.go && go run /tmp/main.go`],
    rust: ['sh', '-c', `echo '${code}' > /tmp/main.rs && rustc /tmp/main.rs -o /tmp/main && /tmp/main`],
    ruby: ['ruby', '-e', code]
  };

  try {
    // Create container
    const container = await docker.createContainer({
      Image: image,
      Cmd: commands[language],
      HostConfig: {
        Memory: 128 * 1024 * 1024, // 128MB
        MemorySwap: 128 * 1024 * 1024,
        CpuQuota: 50000, // 50% CPU
        NetworkMode: 'none', // No network access
        AutoRemove: true
      },
      Tty: false,
      AttachStdout: true,
      AttachStderr: true
    });

    // Start container
    await container.start();

    // Wait for completion with timeout
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Execution timeout')), timeout);
    });

    const resultPromise = container.wait();
    const result = await Promise.race([resultPromise, timeoutPromise]);

    // Get logs
    const logs = await container.logs({ stdout: true, stderr: true });
    const output = logs.toString('utf8');

    return {
      success: result.StatusCode === 0,
      exitCode: result.StatusCode,
      output: output.substring(0, 10000), // Limit output
      language,
      containerId: container.id.substring(0, 12)
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
      language
    };
  }
}

/**
 * Execute system command (restricted)
 */
async function executeSystemCommand(command, timeout = EXECUTION_TIMEOUT) {
  // Whitelist of allowed commands for security
  const allowedCommands = [
    'git', 'curl', 'wget', 'jq', 'cat', 'ls', 'echo', 'grep',
    'head', 'tail', 'sort', 'uniq', 'wc', 'date', 'whoami',
    'pwd', 'mkdir', 'touch', 'cp', 'mv', 'rm', 'find'
  ];

  const cmdBase = command.split(' ')[0];
  if (!allowedCommands.includes(cmdBase)) {
    return {
      success: false,
      error: `Command '${cmdBase}' not allowed. Allowed: ${allowedCommands.join(', ')}`
    };
  }

  try {
    const { stdout, stderr } = await execAsync(command, {
      timeout,
      maxBuffer: 1024 * 1024 // 1MB output limit
    });

    return {
      success: true,
      stdout: stdout.substring(0, 10000),
      stderr: stderr.substring(0, 10000),
      command
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
      stderr: error.stderr?.substring(0, 10000),
      command
    };
  }
}

/**
 * Execute network request
 */
async function executeNetworkRequest(url, method = 'GET', headers = {}, body = null, timeout = 10000) {
  const https = require('https');
  const http = require('http');

  return new Promise((resolve) => {
    const client = url.startsWith('https') ? https : http;
    const urlObj = new URL(url);

    const options = {
      hostname: urlObj.hostname,
      port: urlObj.port,
      path: urlObj.pathname + urlObj.search,
      method: method.toUpperCase(),
      headers: {
        'User-Agent': 'ICholding-Agent/2.0',
        ...headers
      },
      timeout
    };

    const req = client.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        resolve({
          success: true,
          statusCode: res.statusCode,
          headers: res.headers,
          body: data.substring(0, 10000)
        });
      });
    });

    req.on('error', (error) => {
      resolve({
        success: false,
        error: error.message
      });
    });

    req.on('timeout', () => {
      req.destroy();
      resolve({
        success: false,
        error: 'Request timeout'
      });
    });

    if (body) {
      req.write(typeof body === 'string' ? body : JSON.stringify(body));
    }

    req.end();
  });
}

/**
 * Docker container management
 */
async function listDockerContainers(all = false) {
  if (!docker) {
    return { success: false, error: 'Docker not available' };
  }

  try {
    const containers = await docker.listContainers({ all });
    return {
      success: true,
      containers: containers.map(c => ({
        id: c.Id.substring(0, 12),
        names: c.Names,
        image: c.Image,
        state: c.State,
        status: c.Status
      }))
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function getDockerContainerStats(containerId) {
  if (!docker) {
    return { success: false, error: 'Docker not available' };
  }

  try {
    const container = docker.getContainer(containerId);
    const stats = await container.stats({ stream: false });
    return { success: true, stats };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function stopDockerContainer(containerId) {
  if (!docker) {
    return { success: false, error: 'Docker not available' };
  }

  try {
    const container = docker.getContainer(containerId);
    await container.stop();
    return { success: true, message: `Container ${containerId} stopped` };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Health check
 */
async function healthCheck() {
  const checks = {
    isolatedVM: true,
    docker: !!docker,
    timestamp: new Date().toISOString()
  };

  // Test isolated VM
  try {
    const test = await executeIsolatedJS('return 1 + 1', 5000);
    checks.isolatedVM = test.success;
  } catch (e) {
    checks.isolatedVM = false;
  }

  // Test Docker
  if (docker) {
    try {
      await docker.ping();
      checks.docker = true;
    } catch (e) {
      checks.docker = false;
    }
  }

  return checks;
}

// Export all functions
module.exports = {
  // Isolated execution
  executeIsolatedJS,
  // Docker execution
  executeInDocker,
  // System commands
  executeSystemCommand,
  // Network requests
  executeNetworkRequest,
  // Docker management
  listDockerContainers,
  getDockerContainerStats,
  stopDockerContainer,
  // Health
  healthCheck
};
