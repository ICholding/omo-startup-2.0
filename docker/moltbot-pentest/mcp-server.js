/**
 * ICholding MCP (Model Context Protocol) Server
 * Exposes agent capabilities via MCP protocol for Claude Desktop and other MCP clients
 */

const github = require('./github');
const executor = require('./executor');
const memory = require('./memory');

// Store registered tools
const tools = new Map();
const resources = new Map();

// Tool definitions
const toolDefinitions = {
  // GitHub Tools
  github_list_repos: {
    description: 'List GitHub repositories for an organization or user',
    parameters: {
      owner: { type: 'string', description: 'GitHub organization or username' }
    },
    handler: async ({ owner }) => github.listRepositories(owner)
  },
  github_get_repo: {
    description: 'Get repository details',
    parameters: {
      owner: { type: 'string' },
      repo: { type: 'string' }
    },
    handler: async ({ owner, repo }) => github.getRepository(owner, repo)
  },
  github_get_file: {
    description: 'Get file contents from a repository',
    parameters: {
      owner: { type: 'string' },
      repo: { type: 'string' },
      path: { type: 'string' },
      ref: { type: 'string', optional: true }
    },
    handler: async ({ owner, repo, path, ref = 'main' }) => github.getFileContents(owner, repo, path, ref)
  },
  github_update_file: {
    description: 'Create or update a file in a repository',
    parameters: {
      owner: { type: 'string' },
      repo: { type: 'string' },
      path: { type: 'string' },
      content: { type: 'string' },
      message: { type: 'string' },
      branch: { type: 'string', optional: true }
    },
    handler: async ({ owner, repo, path, content, message, branch = 'main' }) => 
      github.createOrUpdateFile(owner, repo, path, content, message, branch)
  },
  github_create_issue: {
    description: 'Create a new GitHub issue',
    parameters: {
      owner: { type: 'string' },
      repo: { type: 'string' },
      title: { type: 'string' },
      body: { type: 'string', optional: true },
      labels: { type: 'array', optional: true }
    },
    handler: async ({ owner, repo, title, body = '', labels = [] }) => 
      github.createIssue(owner, repo, title, body, labels)
  },
  github_list_issues: {
    description: 'List issues in a repository',
    parameters: {
      owner: { type: 'string' },
      repo: { type: 'string' },
      state: { type: 'string', enum: ['open', 'closed', 'all'], optional: true }
    },
    handler: async ({ owner, repo, state = 'open' }) => github.listIssues(owner, repo, state)
  },
  github_create_pull_request: {
    description: 'Create a new pull request',
    parameters: {
      owner: { type: 'string' },
      repo: { type: 'string' },
      title: { type: 'string' },
      head: { type: 'string' },
      base: { type: 'string' },
      body: { type: 'string', optional: true }
    },
    handler: async ({ owner, repo, title, head, base, body = '' }) => 
      github.createPullRequest(owner, repo, title, head, base, body)
  },
  github_list_branches: {
    description: 'List branches in a repository',
    parameters: {
      owner: { type: 'string' },
      repo: { type: 'string' }
    },
    handler: async ({ owner, repo }) => github.listBranches(owner, repo)
  },
  github_create_branch: {
    description: 'Create a new branch',
    parameters: {
      owner: { type: 'string' },
      repo: { type: 'string' },
      branch: { type: 'string' },
      fromBranch: { type: 'string', optional: true }
    },
    handler: async ({ owner, repo, branch, fromBranch = 'main' }) => 
      github.createBranch(owner, repo, branch, fromBranch)
  },
  github_list_commits: {
    description: 'List commits in a repository',
    parameters: {
      owner: { type: 'string' },
      repo: { type: 'string' },
      branch: { type: 'string', optional: true }
    },
    handler: async ({ owner, repo, branch = 'main' }) => github.listCommits(owner, repo, branch)
  },

  // Execution Tools
  execute_javascript: {
    description: 'Execute JavaScript in isolated VM',
    parameters: {
      code: { type: 'string' },
      timeout: { type: 'number', optional: true }
    },
    handler: async ({ code, timeout = 30000 }) => executor.executeIsolatedJS(code, timeout)
  },
  execute_docker: {
    description: 'Execute code in Docker container',
    parameters: {
      code: { type: 'string' },
      language: { type: 'string', enum: ['javascript', 'python', 'bash', 'go', 'rust', 'ruby'] },
      timeout: { type: 'number', optional: true }
    },
    handler: async ({ code, language, timeout = 30000 }) => executor.executeInDocker(code, language, timeout)
  },
  execute_command: {
    description: 'Execute whitelisted system command',
    parameters: {
      command: { type: 'string' },
      timeout: { type: 'number', optional: true }
    },
    handler: async ({ command, timeout = 30000 }) => executor.executeSystemCommand(command, timeout)
  },
  execute_network_request: {
    description: 'Make HTTP/HTTPS request',
    parameters: {
      url: { type: 'string' },
      method: { type: 'string', optional: true },
      headers: { type: 'object', optional: true },
      body: { type: 'string', optional: true },
      timeout: { type: 'number', optional: true }
    },
    handler: async ({ url, method = 'GET', headers = {}, body = null, timeout = 10000 }) => 
      executor.executeNetworkRequest(url, method, headers, body, timeout)
  },

  // Memory Tools
  memory_get: {
    description: 'Retrieve knowledge from memory',
    parameters: {
      key: { type: 'string' }
    },
    handler: async ({ key }) => ({ key, value: await memory.getKnowledge(key) })
  },
  memory_set: {
    description: 'Store knowledge in memory',
    parameters: {
      key: { type: 'string' },
      value: { type: 'string' },
      category: { type: 'string', optional: true }
    },
    handler: async ({ key, value, category = 'general' }) => {
      await memory.setKnowledge(key, value, category);
      return { success: true, key, saved: true };
    }
  },
  memory_get_directives: {
    description: 'Get active agent directives',
    parameters: {},
    handler: async () => memory.getActiveDirectives()
  },
  memory_add_directive: {
    description: 'Add new agent directive',
    parameters: {
      directive: { type: 'string' },
      priority: { type: 'number', optional: true }
    },
    handler: async ({ directive, priority = 5 }) => memory.addDirective(directive, priority, 'Data_eli')
  },
  memory_sync_b2: {
    description: 'Sync memory to Backblaze B2',
    parameters: {},
    handler: async () => memory.syncToB2()
  }
};

// MCP Server class
class MCPServer {
  constructor() {
    this.name = 'icholding-openclaw';
    this.version = '2.0.0';
    this.tools = toolDefinitions;
  }

  async handleRequest(request) {
    const { method, params, id } = request;

    switch (method) {
      case 'initialize':
        return {
          jsonrpc: '2.0',
          id,
          result: {
            protocolVersion: '2024-11-05',
            capabilities: {
              tools: {},
              resources: {}
            },
            serverInfo: {
              name: this.name,
              version: this.version
            }
          }
        };

      case 'tools/list':
        return {
          jsonrpc: '2.0',
          id,
          result: {
            tools: Object.entries(this.tools).map(([name, tool]) => ({
              name,
              description: tool.description,
              parameters: tool.parameters
            }))
          }
        };

      case 'tools/call':
        const { name, arguments: args } = params;
        const tool = this.tools[name];
        if (!tool) {
          return {
            jsonrpc: '2.0',
            id,
            error: { code: -32601, message: `Tool not found: ${name}` }
          };
        }
        try {
          const result = await tool.handler(args);
          return {
            jsonrpc: '2.0',
            id,
            result: {
              content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
            }
          };
        } catch (error) {
          return {
            jsonrpc: '2.0',
            id,
            result: {
              content: [{ type: 'text', text: JSON.stringify({ error: error.message }) }],
              isError: true
            }
          };
        }

      case 'resources/list':
        return {
          jsonrpc: '2.0',
          id,
          result: {
            resources: [
              { uri: 'github://repos', name: 'GitHub Repositories', mimeType: 'application/json' },
              { uri: 'memory://stats', name: 'Memory Statistics', mimeType: 'application/json' }
            ]
          }
        };

      case 'resources/read':
        const { uri } = params;
        if (uri === 'github://repos') {
          const result = await github.listRepositories('ICholding');
          return {
            jsonrpc: '2.0',
            id,
            result: {
              contents: [{ uri, mimeType: 'application/json', text: JSON.stringify(result, null, 2) }]
            }
          };
        }
        if (uri === 'memory://stats') {
          const result = await memory.getStats();
          return {
            jsonrpc: '2.0',
            id,
            result: {
              contents: [{ uri, mimeType: 'application/json', text: JSON.stringify(result, null, 2) }]
            }
          };
        }
        return {
          jsonrpc: '2.0',
          id,
          error: { code: -32602, message: `Resource not found: ${uri}` }
        };

      default:
        return {
          jsonrpc: '2.0',
          id,
          error: { code: -32601, message: `Method not found: ${method}` }
        };
    }
  }
}

// Create singleton instance
const mcpServer = new MCPServer();

module.exports = {
  MCPServer,
  mcpServer,
  toolDefinitions
};
