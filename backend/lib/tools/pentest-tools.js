/**
 * Pentest Tools Module - Security Testing Capabilities
 * 
 * Integrated into OMO Execution Engine for authorized security assessments
 * All tools include safety controls and logging
 */

const { exec } = require('child_process');
const https = require('https');
const http = require('http');
const dns = require('dns');
const { promisify } = require('util');
const dnsLookup = promisify(dns.lookup);
const dnsResolve = promisify(dns.resolve);

class PentestTools {
  constructor() {
    this.allowedTargets = process.env.ALLOWED_PENTEST_TARGETS?.split(',') || [];
    this.timeoutMs = 30000;
    this.maxPorts = 1000;
  }

  /**
   * Validate target is authorized for testing
   */
  validateTarget(target) {
    // If no whitelist defined, allow all (for development)
    if (this.allowedTargets.length === 0) {
      return { valid: true };
    }
    
    const isAllowed = this.allowedTargets.some(allowed => 
      target.includes(allowed) || target === allowed
    );
    
    if (!isAllowed) {
      return { 
        valid: false, 
        error: `Target '${target}' not in authorized list: ${this.allowedTargets.join(', ')}` 
      };
    }
    
    return { valid: true };
  }

  /**
   * Port Scanning - Fast TCP port scanner
   */
  async portScan(target, options = {}) {
    const validation = this.validateTarget(target);
    if (!validation.valid) return validation;

    const ports = options.ports || [80, 443, 22, 21, 25, 3306, 5432, 8080, 8443];
    const timeout = options.timeout || 2000;
    
    if (ports.length > this.maxPorts) {
      return { 
        status: 'error', 
        error: `Max ${this.maxPorts} ports allowed. Use specific range.` 
      };
    }

    console.log(`[Pentest] Port scanning ${target} on ${ports.length} ports`);
    
    const results = [];
    const batchSize = 50; // Concurrent connections
    
    for (let i = 0; i < ports.length; i += batchSize) {
      const batch = ports.slice(i, i + batchSize);
      const batchPromises = batch.map(port => this.checkPort(target, port, timeout));
      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults.filter(r => r.open));
    }

    return {
      status: 'success',
      target,
      openPorts: results,
      totalScanned: ports.length,
      summary: `Found ${results.length} open ports: ${results.map(r => r.port).join(', ')}`
    };
  }

  async checkPort(host, port, timeout) {
    return new Promise((resolve) => {
      const socket = new (require('net')).Socket();
      socket.setTimeout(timeout);
      
      socket.on('connect', () => {
        socket.destroy();
        resolve({ port, open: true, service: this.getCommonService(port) });
      });
      
      socket.on('timeout', () => {
        socket.destroy();
        resolve({ port, open: false });
      });
      
      socket.on('error', () => {
        resolve({ port, open: false });
      });
      
      socket.connect(port, host);
    });
  }

  getCommonService(port) {
    const services = {
      21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
      53: 'DNS', 80: 'HTTP', 110: 'POP3', 143: 'IMAP',
      443: 'HTTPS', 3306: 'MySQL', 5432: 'PostgreSQL',
      8080: 'HTTP-Alt', 8443: 'HTTPS-Alt'
    };
    return services[port] || 'Unknown';
  }

  /**
   * Web Vulnerability Scanner - Basic checks
   */
  async webScan(url, options = {}) {
    const validation = this.validateTarget(new URL(url).hostname);
    if (!validation.valid) return validation;

    console.log(`[Pentest] Web scanning ${url}`);
    
    const results = {
      url,
      timestamp: new Date().toISOString(),
      checks: {}
    };

    try {
      // Check headers
      const headers = await this.getHeaders(url);
      results.checks.securityHeaders = this.analyzeSecurityHeaders(headers);
      
      // Check for common paths
      if (options.bruteForcePaths) {
        results.checks.commonPaths = await this.checkCommonPaths(url);
      }
      
      // SSL/TLS check for HTTPS
      if (url.startsWith('https')) {
        results.checks.ssl = await this.checkSSL(url);
      }
      
      // Basic fingerprinting
      results.checks.fingerprint = this.fingerprintTechnology(headers);
      
      results.status = 'success';
      results.summary = this.summarizeWebFindings(results.checks);
      
    } catch (error) {
      results.status = 'error';
      results.error = error.message;
    }

    return results;
  }

  async getHeaders(url) {
    return new Promise((resolve, reject) => {
      const client = url.startsWith('https') ? https : http;
      const req = client.request(url, { method: 'HEAD', timeout: 10000 }, (res) => {
        resolve(res.headers);
      });
      req.on('error', reject);
      req.on('timeout', () => reject(new Error('Timeout')));
      req.end();
    });
  }

  analyzeSecurityHeaders(headers) {
    const securityHeaders = {
      'Strict-Transport-Security': headers['strict-transport-security'],
      'Content-Security-Policy': headers['content-security-policy'],
      'X-Frame-Options': headers['x-frame-options'],
      'X-Content-Type-Options': headers['x-content-type-options'],
      'X-XSS-Protection': headers['x-xss-protection'],
      'Referrer-Policy': headers['referrer-policy']
    };

    const missing = Object.entries(securityHeaders)
      .filter(([_, value]) => !value)
      .map(([header]) => header);

    return {
      present: Object.entries(securityHeaders).filter(([_, v]) => v).map(([h]) => h),
      missing,
      risk: missing.length > 3 ? 'High' : missing.length > 0 ? 'Medium' : 'Low'
    };
  }

  async checkCommonPaths(baseUrl) {
    const commonPaths = [
      '/admin', '/login', '/api', '/.env', '/.git', 
      '/robots.txt', '/sitemap.xml', '/phpmyadmin'
    ];
    
    const results = [];
    const promises = commonPaths.map(async (path) => {
      try {
        const url = new URL(path, baseUrl).toString();
        const res = await fetch(url, { method: 'HEAD', timeout: 5000 });
        if (res.status === 200) {
          results.push({ path, status: res.status, exists: true });
        }
      } catch {}
    });
    
    await Promise.all(promises);
    return results;
  }

  async checkSSL(url) {
    // Basic SSL info extraction
    try {
      const tls = require('tls');
      const parsed = new URL(url);
      
      return new Promise((resolve) => {
        const socket = tls.connect(443, parsed.hostname, { rejectUnauthorized: false }, () => {
          const cert = socket.getPeerCertificate();
          socket.end();
          
          resolve({
            valid: cert.valid_to ? new Date(cert.valid_to) > new Date() : false,
            validUntil: cert.valid_to,
            issuer: cert.issuer?.O || 'Unknown',
            subject: cert.subject?.CN || 'Unknown',
            protocol: socket.getProtocol()
          });
        });
        
        socket.on('error', () => resolve({ error: 'SSL check failed' }));
        socket.setTimeout(10000, () => resolve({ error: 'SSL timeout' }));
      });
    } catch (error) {
      return { error: error.message };
    }
  }

  fingerprintTechnology(headers) {
    const tech = [];
    const server = headers.server || '';
    const powered = headers['x-powered-by'] || '';
    
    if (server.includes('nginx')) tech.push('Nginx');
    if (server.includes('Apache')) tech.push('Apache');
    if (server.includes('cloudflare')) tech.push('Cloudflare');
    if (powered.includes('PHP')) tech.push('PHP');
    if (powered.includes('Express')) tech.push('Express.js');
    if (headers['x-aspnet-version']) tech.push('ASP.NET');
    
    return tech;
  }

  summarizeWebFindings(checks) {
    const issues = [];
    if (checks.securityHeaders?.risk === 'High') issues.push('Missing critical security headers');
    if (checks.commonPaths?.length > 0) issues.push(`Found ${checks.commonPaths.length} accessible paths`);
    if (checks.ssl && !checks.ssl.valid) issues.push('SSL certificate issues');
    
    return issues.length > 0 
      ? `Issues found: ${issues.join(', ')}`
      : 'No immediate issues detected';
  }

  /**
   * DNS Reconnaissance
   */
  async dnsRecon(domain, options = {}) {
    const validation = this.validateTarget(domain);
    if (!validation.valid) return validation;

    console.log(`[Pentest] DNS recon on ${domain}`);
    
    const results = {
      domain,
      timestamp: new Date().toISOString(),
      records: {}
    };

    try {
      // A records
      try {
        const aRecords = await dnsResolve(domain, 'A');
        results.records.a = aRecords;
      } catch {}

      // MX records
      try {
        const mxRecords = await dnsResolve(domain, 'MX');
        results.records.mx = mxRecords;
      } catch {}

      // NS records
      try {
        const nsRecords = await dnsResolve(domain, 'NS');
        results.records.ns = nsRecords;
      } catch {}

      // TXT records (SPF, DMARC)
      try {
        const txtRecords = await dnsResolve(domain, 'TXT');
        results.records.txt = txtRecords;
        results.security = this.analyzeDNSecurity(txtRecords);
      } catch {}

      // Subdomain enumeration (basic)
      if (options.subdomains) {
        results.subdomains = await this.enumerateSubdomains(domain);
      }

      results.status = 'success';
      results.summary = `Found ${Object.keys(results.records).length} record types`;
      
    } catch (error) {
      results.status = 'error';
      results.error = error.message;
    }

    return results;
  }

  analyzeDNSecurity(txtRecords) {
    const flat = txtRecords.flat().join(' ');
    return {
      spf: flat.includes('v=spf1'),
      dmarc: flat.includes('v=DMARC1'),
      dkim: flat.includes('DKIM1'),
      recommendations: []
        .concat(!flat.includes('v=spf1') ? 'Add SPF record' : [])
        .concat(!flat.includes('v=DMARC1') ? 'Add DMARC record' : [])
    };
  }

  async enumerateSubdomains(domain) {
    const commonSubs = ['www', 'mail', 'ftp', 'admin', 'api', 'blog', 'shop', 'dev', 'staging'];
    const found = [];
    
    const promises = commonSubs.map(async (sub) => {
      try {
        const fullDomain = `${sub}.${domain}`;
        await dnsLookup(fullDomain);
        found.push(fullDomain);
      } catch {}
    });
    
    await Promise.all(promises);
    return found;
  }

  /**
   * HTTP Request Inspector
   */
  async httpInspect(url, options = {}) {
    const validation = this.validateTarget(new URL(url).hostname);
    if (!validation.valid) return validation;

    console.log(`[Pentest] HTTP inspect ${url}`);
    
    try {
      const response = await fetch(url, {
        method: options.method || 'GET',
        headers: options.headers || {},
        redirect: 'manual'
      });

      const body = await response.text();
      
      return {
        status: 'success',
        url,
        statusCode: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers),
        bodyPreview: body.substring(0, 2000),
        redirects: response.redirected,
        cookies: response.headers.get('set-cookie')
      };
    } catch (error) {
      return { status: 'error', error: error.message };
    }
  }

  /**
   * SSL/TLS Scanner
   */
  async sslScan(host, port = 443) {
    const validation = this.validateTarget(host);
    if (!validation.valid) return validation;

    console.log(`[Pentest] SSL scan ${host}:${port}`);
    
    return new Promise((resolve) => {
      const tls = require('tls');
      const socket = tls.connect(port, host, {
        rejectUnauthorized: false,
        servername: host
      }, () => {
        const cipher = socket.getCipher();
        const cert = socket.getPeerCertificate();
        
        socket.end();
        
        resolve({
          status: 'success',
          host,
          port,
          protocol: cipher.version,
          cipher: cipher.name,
          certificate: {
            subject: cert.subject,
            issuer: cert.issuer,
            validFrom: cert.valid_from,
            validTo: cert.valid_to,
            fingerprint: cert.fingerprint
          },
          secure: cipher.version !== 'TLSv1' && cipher.version !== 'TLSv1.1'
        });
      });
      
      socket.on('error', (err) => resolve({ status: 'error', error: err.message }));
      socket.setTimeout(15000, () => resolve({ status: 'error', error: 'Timeout' }));
    });
  }

  /**
   * Main dispatcher
   */
  async execute(scanType, target, options = {}) {
    console.log(`[Pentest] ${scanType} on ${target}`);
    
    switch (scanType) {
      case 'port_scan':
      case 'portscan':
        return this.portScan(target, options);
        
      case 'web_scan':
      case 'webscan':
        return this.webScan(target, options);
        
      case 'dns_recon':
      case 'dnsrecon':
        return this.dnsRecon(target, options);
        
      case 'http_inspect':
      case 'httpinspect':
        return this.httpInspect(target, options);
        
      case 'ssl_scan':
      case 'sslscan':
        return this.sslScan(target, options.port);
        
      default:
        return { 
          status: 'error', 
          error: `Unknown scan type: ${scanType}. Available: port_scan, web_scan, dns_recon, http_inspect, ssl_scan` 
        };
    }
  }
}

module.exports = new PentestTools();
